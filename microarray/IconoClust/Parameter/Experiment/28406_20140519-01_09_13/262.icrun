<?xml version='1.0' encoding='ISO-8859-1'?>
<PROCESS owner="" password="d41d8cd98f00b204e9800998ecf8427e" script="CCT._Description = {
&quot;Author&quot; : 	&quot;Clondiag Chip Technologies&quot;,
&quot;Target&quot; : 	&quot;Processing of Standard Array Tube Experiments&quot;,
&quot;Description&quot; : 	'''
		Script processes last image in experiment.
		The Results are graphed in a special Presentation Component.
		Model-based Segmentation is optional.
		Automatic Reference System Recognition is optional.
		Results can be normalized by named substance value.''',
&quot;Parameter&quot; : 	'''
		icprm_spot_color:		DARK or BRIGHT
		icprm_mode:		0 for fixed segmentation according to layout
					1 for Model-based Segmentation
		icprm_ref_mode:		MANUAL for manual setting of Reference Points
					AUTO for Automatic Reference System Detection
					AUTO_CHROME for Automatic Chrome Reference System Detection
		icprm_silent:		0 for enabling user interaction
					1 for suppressing user interaction
		icprm_subst_norm:	Name of normalizing substance
					If empty the name will be entered in a dialog
		icprm_conf_ind:		determine Confidence Index (CI)
					A spot is set invalid if CI &lt; 0.75 and Signal &gt; 0.1
		icprm_signal:		0 for Signal = Local Background - Mean
					1 for Signal = 1 - Mean / Local Background (only allowed for colorimetric detection)

		icprm_save_segimage:	GENERIC_NAME

		''',


&quot;Version&quot; : 	&quot;3.1r1&quot;,
&quot;ScriptVersion&quot; : &quot;2008-04-24&quot;

}

__ICPRM__ = { &quot;icprm_spot_color&quot;:	&quot;DARK&quot;,	
		&quot;icprm_mode&quot;: 		&quot;1&quot;,
		&quot;icprm_ref_mode&quot;:	&quot;AUTO_CHROME&quot;,
		&quot;icprm_silent&quot;:		&quot;1&quot;,
		&quot;icprm_subst_norm&quot;:	&quot;''&quot;,	
		&quot;icprm_conf_ind&quot;:		&quot;1&quot;,	
		&quot;icprm_signal&quot;:		&quot;1&quot;,
		&quot;icprm_save_segimage&quot;:	&quot;0&quot;,
		}

__SpotAligning = 1


#TOM:PROFILING block start
import time
tStart = time.time()
#TOM:PROFILING block end 

import win32gui

BRIGHT = 1
DARK = 2

MANUAL = 0
AUTO = 1
AUTO_CHROME = 2

images = CCT.GetSortedImageIDs()
# use last image
image = images[-1]
CCT.CommitImages( image )
if icprm_mode:
	mode = 2
else:
	mode = 0
# only allow model-based segmentation or fixed ROI
ref_mode = icprm_ref_mode

# the equation 1 - Mean / BG is only allowed for colorimetric detection
if ( icprm_spot_color == BRIGHT ) and ( icprm_signal == 1 ):
	verified_icprm_signal = 0
else:
	verified_icprm_signal = icprm_signal

import ATProcess

img_supp = ImageSupport.ImageSupport()
size = img_supp.GetPictureDimensions( image )
img_supp.SetWindow( ( 5, 5, size[0] - 6, size[1] - 6 ), image )

if ref_mode:
	if icprm_spot_color == BRIGHT:
		icono.SnakeSetColorBackground( DARK )
	else:
		icono.SnakeSetColorBackground( BRIGHT )
	if ref_mode == AUTO:
		icono.SnakeSetInvalidTestScene( 2 )
		icono.SnakeSetAllowedInvalidTestScene( 0.0 )
		processor = ATProcess.Processor( mode, 1 )
		# criterion is maximum contrast, consider homogenity, favour larger scale
		mode_law = 5 | 256 | 512
		icono.SnakeSetSigmaConstraint( 0.2 )
	elif ref_mode == AUTO_CHROME:
		# do not preprocess image for ref detection
		processor = ATProcess.Processor( mode, 0 )
		# criterion is mean extremum, do not consider homogenity, do not favour any scale
		mode_law = 8
		icono.SnakeSetSigmaConstraint( 1.0 )
		#icono.SnakeSetShowRng( 1 )
	ref_id = processor.ProcessRefImage( image ) 
	ref_param = {   &quot;image_ref&quot;: ref_id,
                       &quot;mode_law&quot;: mode_law,
                       &quot;trans_opt&quot;: ( 0.05, 0.03, 0.15, 0.14, 0.14, 1.0, 1.0 ),
                       &quot;param_opt&quot;: ( 25.0, 0.8, 5000.0, 5000.0, 0.0, 0.0005, 0.0, 0.01 ),
                       &quot;weight_probes&quot;: 0.0
                    } 
	ref_auto = 1
else:
	processor = ATProcess.Processor( mode, 0 )
	ref_param = {}
	ref_auto = 0

#first determine the reference system and outer spots
CCT.RunAlignment( img = image, mode = 0, 
            param = { &quot;Transformation&quot;: ( ref_auto, ( 0.05, ), ref_param ) } )

if mode == 2 and icprm_spot_color == BRIGHT:		#model-based
	icono.InvertImage( image, image )



parameter = { &quot;Thresholding&quot;: ( 4, ( 0.7, 0.0, 0.0, 0.2, 0.2, 1.0, 1.0 ) ),
		&quot;Segmentation&quot;: ( 0, ( 200.0, 0.3, 2500.0, 2500.0, 1.0, 0.00001, 0.0, 0.001 ) ) }

if icprm_conf_ind != 1:
	# wird bei Confidence nochmal mit parameter ausgefuehrt
	try:
		#now determine the spots
		img_id = processor.ProcessImage( image ) 
		CCT.RunAlignment( img = img_id, trans = 0, mode = mode, callSource = CODE,
				    param = parameter )
	finally:
		if mode == 2 and icprm_spot_color == BRIGHT:		#model-based
			icono.InvertImage( image, image )

if CCT.vb_control:
	CCT.vb_control.SetModeShowROI( &quot;ROI_FILLED&quot; )
	CCT.vb_control.SetOpacityShowROI( 20 )

#TOM:PROFILING block start
print &quot;SpotAligning:: ENDE&quot;, time.time() - tStart
#TOM:PROFILING block end 

__SpotAligning = 0

__DetFeatures = 1

image = CCT.GetCurrentImage()

if icprm_conf_ind == 1:
	img_id = processor.ProcessImage( image )

	import Confidence

	checker = Confidence.ConfidenceChecker( img_id, image, colour = icprm_spot_color )
	checker.SetEnviron( CCT )
	ci_results = checker.Check( parameter, set = { 'bg': { 'on': 0 } }, signal = verified_icprm_signal )


#TOM:PROFILING block start
print &quot;Nach Confidence&quot;, time.time() - tStart	# cprm_ darf nich clartext in string
#TOM:PROFILING block end 


if icprm_spot_color == BRIGHT:
	hist_par_spot = ( 0.7, 1.0 )
	hist_par_back = ( 0.0, 0.3 )
else:
	hist_par_back = ( 0.7, 1.0 )
	hist_par_spot = ( 0.0, 0.3 )

back_hist = CCT.DetermineFeatures( image,  ( &quot;Mean&quot;,  ),
                                            REGION_BACK|REGION_HIST, ( 3.0, -3.0, 0.0, 1.0, 0.0 ),
                                            hist_param = hist_par_back )

CCT.DetermineFeatures( image, ( &quot;Mean&quot;,  ), REGION_HIST, hist_param =  hist_par_spot )

len_list = len(CCT.features[&quot;Mean&quot;])

if icprm_spot_color == DARK:
	if verified_icprm_signal == 0:
		CCT.features[&quot;Signal&quot;] = [( back_hist[&quot;Mean&quot;][i] - CCT.features[&quot;Mean&quot;][i] ) for i in xrange( len_list ) ]
	elif verified_icprm_signal == 1:
		CCT.features[&quot;Signal&quot;] = [0 for i in xrange( len_list ) ]
		for i in xrange( len_list ):
			try:
				CCT.features[&quot;Signal&quot;][i] = 241.0 / 256.0 * ( 1 - CCT.features[&quot;Mean&quot;][i] / back_hist[&quot;Mean&quot;][i] )
			except:
				pass
elif icprm_spot_color == BRIGHT:
	if verified_icprm_signal == 0:
		CCT.features[&quot;Signal&quot;] = [( CCT.features[&quot;Mean&quot;][i] - back_hist[&quot;Mean&quot;][i]) for i in xrange( len_list ) ]

CCT.features[&quot;Background&quot;] = [back_hist[&quot;Mean&quot;][i] for i in xrange( len_list ) ]

if icprm_conf_ind == 1:
	for ci_key, ci_list in ci_results.iteritems():
		CCT.features[ci_key] = [ci_list[i] for i in xrange( len( ci_list ) ) ]

valid = CCT.features['Valid']

#TOM:PROFILING block start
print &quot;Vor Seg Img&quot;, time.time() - tStart
#TOM:PROFILING block end 


#---------------------------------------------------------------
# save segmentation image 
#---------------------------------------------------------------
try:
	seg_name = CCT.segImageName
except:
	seg_name = &quot;&quot;
if icprm_save_segimage == 2:
	seg_name = CCT.GetImageName(image) #+ name noch bearbeiten

if seg_name:
	ic_img_path = seg_name + &quot;.png&quot; 
	print &quot;save segmentation image to&quot;, ic_img_path
	CCT.SaveSegImage( ic_img_path, mode = ImageSupport.CCT_ROI, opac = 1.0, add_valid = 1 )

#-----------------------------------------------------------------------------



if CCT.vb_control:
	CCT.vb_control.ShowResults( 1 )
	if not icprm_silent:
		answer = win32gui.MessageBox( 0, 'You can set invalid Spots now.' + chr( 13 ) + \
			'Press &quot;Ok&quot; if you are done.', 'Spot Validity', 5168 )
		valid = CCT.vb_control.GetValidity()
		CCT.features['Valid'] = valid

valid_indx = []
for i in xrange( len( valid ) ):
	if valid[i] == 0:
		valid_indx.append( i ) 

if not CCT.features.has_key( &quot;Substance&quot; ):
	raise KeyError, &quot;You have to include Spot Descriptions into your Experiment&quot;

CCT.featSubst = []
for subst in CCT.features[&quot;Substance&quot;]:
	try:
		pos = CCT.featSubst.index( subst )
	except:
		CCT.featSubst.append( subst )

CCT.featSubst.sort()

normSubst = &quot;&quot;
if not icprm_subst_norm:
	if not icprm_silent:
		# create dialog and ask for normalizing substance
		from win32com.client import Dispatch
		util = Dispatch( &quot;IconoUtil.Util&quot; )
		normSubst = util.ListSelectEx( &quot;Normalizing Substance&quot;, &quot;Select name of normalizing substance&quot;, &quot;Select&quot;, CCT.featSubst[:], &quot;norm_subst&quot; )
		normSubst = normSubst.strip()

CCT.features['Valid'] = valid

if normSubst:
	# normalize features
	feat_norm = ( &quot;Signal&quot;, &quot;Mean&quot;, &quot;Background&quot;, )
	normFeat = {}
	for feat in feat_norm:
		normFeat[feat] = 0.0
	norm_count = 0
	for i in xrange( len( CCT.features[&quot;Substance&quot;] ) ):
		if valid[i]:
			continue
		subst = CCT.features[&quot;Substance&quot;][i]
		if subst != normSubst:
			continue
		norm_count += 1
		for feat in feat_norm:
			normFeat[feat] += CCT.features[feat][i]
	if not norm_count:
		raise ValueError( &quot;Cannot normalize - no valid spot for substance&quot; )
	for feat in feat_norm:
		if normFeat[feat]:
			normFeat[feat] /= norm_count
			CCT.features[feat] = [ val / normFeat[feat] for val in CCT.features[feat] ]

if not CCT.sources.has_key( &quot;subst_match&quot; ):
	# have to create file with all the substances without any relations
	# name it after the a_probe_on_array file 
	name_match = os.path.basename( CCT.sources[&quot;a_probe_on_array&quot;] )
	name_match = os.path.splitext( name_match )[0] + &quot;.txt&quot;
	name_match = os.path.join( ParamGlobals.GetIconoPath(), &quot;Parameter&quot;, &quot;Layout&quot;, &quot;Substance&quot;, name_match ) 
	cont_match = &quot;Match\tSubstance\n&quot;
	subst_in = []
	for subst in CCT.features[&quot;Substance&quot;]:
		if not subst in subst_in:
			cont_match += subst + '\t' + subst + '\n'
			subst_in.append( subst )
	f = open( name_match, &quot;w&quot; )
	f.write( cont_match )
	f.close()
	import Excel2XMLSubstance
	conv = Excel2XMLSubstance.xl2XML()
	conv.ImportText( name_match )
	name_match = conv.Create()
	CCT.SetParameterSingle( [ ( &quot;subst_match&quot;, name_match ), ] )

# create a dictionary with key value pair: substancename, value
# presentation only creates the mean of the values per substance
substMean = {}
subst_list = CCT.features[&quot;Substance&quot;]
for subst in CCT.featSubst:
	mean_for_subst = []
	for i in xrange( len( subst_list ) ):
		if valid[i] != 0:
			continue
		if subst_list[i] == subst:
			mean_for_subst.append( CCT.features[&quot;Signal&quot;][i] )

	# here we can also deal with outliers
	mean = 0.0
	for val in mean_for_subst:
		mean += val
	if len( mean_for_subst ):
		mean /= len( mean_for_subst )
	substMean[subst] = mean

# signal is inverted since chart control inverts again
CCT.validFeat = { 	&quot;Signal&quot;: 	[ 1.0 - substMean[subst_list[i]] for i in valid_indx ],
			&quot;Valid&quot;:		[ 0.0 for i in valid_indx ],
			&quot;Substance&quot;:	[ subst_list[i] for i in valid_indx ] }

if CCT.vb_control:
	import PresentEnvironAT
	CCT.PresentAT = PresentEnvironAT.PresentEnviron()
	CCT.PresentAT.SetSignalFeature( &quot;Signal&quot; )
	CCT.PresentAT.SetEnviron( CCT, [ CCT.validFeat, ] )
	CCT.PresentAT.SetMode( nr_img = 0, show_img = PresentEnvironAT.ENDPOINT )
	CCT.vb_control.SetPresentation( &quot;PresentAT&quot; )

if verified_icprm_signal == 1:
	CCT.rawResultType = &quot;ic [1MeanBG]&quot;
elif verified_icprm_signal == 0:
	CCT.rawResultType = &quot;ic [MeanBG]&quot;

# set featureMap for Partisan
import ODBC2Magasin
ODBC2Magasin.AppendFeatureMap( &quot;Mean&quot;, &quot;value&quot; )
ODBC2Magasin.AppendFeatureMap( &quot;Signal&quot;, &quot;value2&quot; )
ODBC2Magasin.AppendFeatureMap( &quot;Background&quot;, &quot;local_backgrd&quot; )
ODBC2Magasin.AppendFeatureMap( &quot;Confidence&quot;, &quot;quality&quot; )
ODBC2Magasin.AppendFeatureMap( &quot;Valid&quot;, &quot;flags&quot; )

# make available parameter
CCT.paramProcessing = {}
if seg_name:
	CCT.paramProcessing[&quot;segPath&quot;] = seg_name

#TOM:PROFILING block start
print &quot;Ende script&quot;, time.time() - tStart
#TOM:PROFILING block end 

__DetFeatures = 0

" />